package com.aviator.ketty.conversion;/** * @Author ketty bluce * @Create 2023/7/4 * @Version 1.0 */import cn.hutool.core.io.file.FileReader;import cn.hutool.core.util.StrUtil;import java.io.File;import java.io.FileWriter;import java.io.IOException;import java.util.*;import java.util.regex.Matcher;import java.util.regex.Pattern;import java.util.stream.Collectors;/** * 模板转化类 */public class TemplateConversion {    // 标注公式注入    public static final String calculateFormula = "template/公式模板.av";    // 验证脚本输出    public static final String exampleConvert = "template/example-convert.av";    // 计算脚本输出    public static final String computeConvert = "template/example-calculation.av";    // 比较字母公式    static ArrayList<String> leftLetterList = null;    // 计算字母公式    static ArrayList<String> rightLetterList = null;    // 符号集合    static ArrayList<String> operatorList = null;    public static void main(String[] args) {        // 获取公式内容        FileReader fileReader = new FileReader(calculateFormula);        // 验证脚本String        StringBuilder verification = new StringBuilder();        // 计算脚本String        StringBuilder compute = new StringBuilder();        Boolean flag = true;        // 去除公式的空格        List<String> strings = fileReader.readLines().stream()                .filter(line -> !line.trim().isEmpty())                .collect(Collectors.toList());        // 解析公式        for (int i = 0; i < strings.size(); i++) {            leftLetterList = new ArrayList<>();            rightLetterList = new ArrayList<>();            operatorList = new ArrayList<>();            // 公式样式            String formula = strings.get(i).replaceAll("##脚本：|\\s", "");            // 字符串替换            formula = replaceAll(formula);            // 验证脚本            StringBuilder verificationBuilder = new StringBuilder();            // 计算脚本            StringBuilder computeBuilder = new StringBuilder();            String regex = ".*≤.*≤.*";            Pattern pattern1 = Pattern.compile(regex);            Matcher matcher2 = pattern1.matcher(formula);            String rightLetterString = null;            if (formula.contains(",")) {                String[] split = formula.split(",");                leftLetterList = new ArrayList<>(Arrays.asList(split));                verificationBuilder = TypeTwo(formula, strings.get(i));            } else if (matcher2.matches()) {                String[] strList = formula.split("≤");                String oldSymbol = "<=";                // 左边的数组                String lStr = strList[0];                // 中间字母                String Str = strList[1];                // 右边公式                String rStr = strList[2];                String replacedStr = "";                // 全部字母                String[] newStrList = new String[0];                replacedStr = rStr.replace("+", ",").replace("×", ",").replace("-", ",").replace("*", ",").replace("/", ",").replace("(", "").replace(")", "");                newStrList = replacedStr.split(",");                // 字母集合按顺序实现                rightLetterList = new ArrayList<>(Arrays.asList(newStrList));                // 去除包含数字的元素                rightLetterList = getElementsNotInSet(rightLetterList);                // 生产验证脚本                verificationBuilder = TypeThree(lStr, Str, oldSymbol, rStr, formula, strings.get(i), rStr);            } else {                // 切分成两半                String[] splist = formulaTransformation(formula);                // 比较符号是什么                String oldSymbol = fransFormation(formula);                // 左边的字母                String aStr = splist[0];                // 右边的字母                String bStr = splist[1];                // 字符串                rightLetterString = null;                // 右边的字母-比较字母公式                if (aStr.length() > bStr.length()) {                    // 比较字母                    leftLetterList.add(bStr);                    // 标识                    flag = false;                    oldSymbol = formulaMapping(oldSymbol, false);                    rightLetterString = aStr;                    String replacedStr = "";                    // 全部字母                    String[] newStrList = new String[0];                    replacedStr = aStr.replace("+", ",").replace("×", ",").replace("-", ",").replace("*", ",").replace("/", ",").replace("(", "").replace(")", "");                    newStrList = replacedStr.split(",");                    // 字母集合按顺序实现                    rightLetterList = new ArrayList<>(Arrays.asList(newStrList));                    // 左边的字母-比较字母公式                } else {                    // 比较字母                    leftLetterList.add(aStr);                    // 标识                    flag = true;                    oldSymbol = formulaMapping(oldSymbol, true);                    rightLetterString = bStr;                    String[] newStrList = new String[0];                    String replacedStr = "";                    replacedStr = bStr.replace("+", ",").replace("-", ",").replace("*", ",")                            .replace("/", ",").replace("(", "").replace(")", "").replace("×", ",");                    newStrList = replacedStr.split(",");                    // 字母集合按顺序实现                    rightLetterList = new ArrayList<>(Arrays.asList(newStrList));                }                if (rightLetterList.size() > 1) {                    // 去除包含数字的元素                    rightLetterList = getElementsNotInSet(rightLetterList);                }                // 开始拼接-验证脚本                verificationBuilder = TypeOne(oldSymbol, rightLetterString, formula, strings.get(i));                // 开始拼接-计算脚本                computeBuilder = computeOne(oldSymbol, rightLetterString, aStr, strings.get(i), flag);            }            verification.append(verificationBuilder);            compute.append(computeBuilder);        }        // 开始执行打印字符        generateFile(exampleConvert, verification.toString());        // 开始打印计算脚本        generateComputeFile(computeConvert, compute.toString());    }    private static StringBuilder computeOne(String oldSymbol, String rightLetterString, String formula, String s, Boolean flag) {        StringBuilder computeBuilder = new StringBuilder();        computeBuilder.append(s + "\n");        String quotes = "\"";        computeBuilder.append("if(");        for (int j = 0; j < rightLetterList.size(); j++) {            String character = rightLetterList.get(j);            if ("D".equals(character) && j == 0) {                computeBuilder.append("D!=nil ");                continue;            } else if ("D".equals(character) && j > 0) {                computeBuilder.append("&& D!=nil ");                continue;            }            if (j == 0) {                computeBuilder.append("inputInspection(" + generate(character) + "," + quotes + character + quotes + ")");            } else {                computeBuilder.append(" && inputInspection(" + generate(character) + "," + quotes + character + quotes + ") ");            }        }        computeBuilder.append("){" + "\n");        for (int j = 0; j < rightLetterList.size(); j++) {            String character = rightLetterList.get(j);            if ("D".equals(character)) {                computeBuilder.append("    D=decimal(D);" + "\n");                continue;            }            computeBuilder.append("    let " + character + "=fetchValue(" + generate(character) + "," + quotes + character + quotes + ");" + "\n");        }        // L=L-LB-LA-LC-HB; 公式计算        computeBuilder.append("    " + rightLetterList.get(0) + "=" + rightLetterString + ";\n");        if (">=".equals(oldSymbol) && flag) {            computeBuilder.append("    changeMinimum(" + rightLetterList.get(0) + ",list," + quotes + formula + quotes + ",true);\n");        } else if (">=".equals(oldSymbol) && !flag) {            computeBuilder.append("    changeMaximum(" + rightLetterList.get(0) + ",list," + quotes + formula + quotes + ",true);\n");        } else if ("<=".equals(oldSymbol) && flag) {            computeBuilder.append("    changeMaximum(" + rightLetterList.get(0) + ",list," + quotes + formula + quotes + ",true);\n");        } else if ("<=".equals(oldSymbol) && !flag) {            computeBuilder.append("    changeMinimum(" + rightLetterList.get(0) + ",list," + quotes + formula + quotes + ",true);\n");        }        computeBuilder.append("}" + "\n");        return computeBuilder;    }    private static String generate(String str) {        HashMap<String, String> map = new HashMap<>();        map.put("L", "attrSpec");        map.put("LA", "attrSpec");        map.put("LB", "attrSpec");        map.put("LC", "attrSpec");        map.put("P", "genSpec");        map.put("Q", "attrSpec");        map.put("T", "genSpec");        if (map.containsKey(str)) {            return map.get(str);        } else {            return "appendSpec";        }    }    private static StringBuilder TypeThree(String lStr, String Str, String oldSymbol, String rightLetterString, String formula, String s, String rStr) {        StringBuilder verificationBuilder = new StringBuilder();        verificationBuilder.append(s + "\n");        verificationBuilder.append("let errmsg = nil;" + "\n");        verificationBuilder.append("if(");        verificationBuilder.append(Str + "!= nil");        for (int j = 0; j < rightLetterList.size(); j++) {            String character = rightLetterList.get(j);            verificationBuilder.append(" && " + character + "!= nil");        }        verificationBuilder.append("){" + "\n");        verificationBuilder.append("   " + Str + "=decimal(" + Str + ");" + "\n");        for (int j = 0; j < rightLetterList.size(); j++) {            String character = rightLetterList.get(j);            verificationBuilder.append("   " + character + "=decimal(" + character + ");" + "\n");        }        if (rightLetterList.size() > 0) {            verificationBuilder.append("   " + "let " + rightLetterList.get(0) + "=" + rightLetterString + ";\n");        }        verificationBuilder.append("   if(");        verificationBuilder.append(lStr + oldSymbol + Str + " && ");        if (rightLetterList.size() > 0) {            verificationBuilder.append(Str + oldSymbol + rightLetterList.get(0));        } else {            verificationBuilder.append(Str + oldSymbol + rStr);        }        verificationBuilder.append("){" + "\n");        verificationBuilder.append("       " + "return true;" + "\n");        verificationBuilder.append("   " + "}else{" + "\n");        verificationBuilder.append("       " + "errmsg = \"需满足公式 " + formula + "\";" + "\n");        verificationBuilder.append("       " + "return errmsg;" + "\n");        verificationBuilder.append("   " + "}" + "\n");        verificationBuilder.append("}" + "\n");        verificationBuilder.append("return true;" + "\n");        verificationBuilder.append("\n");        return verificationBuilder;    }    private static StringBuilder TypeTwo(String formula, String str) {        StringBuilder verificationBuilder = new StringBuilder();        verificationBuilder.append(str + "\n");        verificationBuilder.append("let errmsg = nil;" + "\n");        verificationBuilder.append("if(");        if (leftLetterList.size() == 2) {            for (int i = 0; i < leftLetterList.size(); i++) {                String character = leftLetterList.get(i);                if (i == 0) {                    verificationBuilder.append("(" + character + "!= nil");                } else {                    verificationBuilder.append(" && " + character + "!= nil" + ")");                }            }            verificationBuilder.append("||");            for (int i = 0; i < leftLetterList.size(); i++) {                String character = leftLetterList.get(i);                if (i == 0) {                    verificationBuilder.append("(" + character + "== nil");                } else {                    verificationBuilder.append(" && " + character + "== nil" + ")");                }            }        } else {            for (int i = 0; i < leftLetterList.size(); i++) {                String character = leftLetterList.get(i);                if (i == 0) {                    verificationBuilder.append("(" + character + "!= nil");                } else if (i == 1) {                    verificationBuilder.append(" && " + character + "!= nil");                } else {                    verificationBuilder.append(" && " + character + "!= nil" + ")");                }            }            verificationBuilder.append("||");            for (int i = 0; i < leftLetterList.size(); i++) {                String character = leftLetterList.get(i);                if (i == 0) {                    verificationBuilder.append("(" + character + "== nil");                } else if (i == 1) {                    verificationBuilder.append(" && " + character + "== nil");                } else {                    verificationBuilder.append(" && " + character + "== nil" + ")");                }            }        }        verificationBuilder.append("){" + "\n");        verificationBuilder.append("    " + "return true;" + "\n");        verificationBuilder.append("} else {" + "\n");        verificationBuilder.append("   errmsg = \"" + "型号中需指定下述参数。(" + formula.replace(",", " ") + ")" + "\";" + "\n");        verificationBuilder.append("   return errmsg;" + "\n");        verificationBuilder.append("}" + "\n");        verificationBuilder.append("\n");        return verificationBuilder;    }    private static StringBuilder TypeOne(String oldSymbol, String rightLetterString, String formula, String str) {        StringBuilder verificationBuilder = new StringBuilder();        verificationBuilder.append(str + "\n");        verificationBuilder.append("let errmsg = nil;" + "\n");        verificationBuilder.append("if(");        verificationBuilder.append(leftLetterList.get(0) + "!= nil");        for (int j = 0; j < rightLetterList.size(); j++) {            String character = rightLetterList.get(j);            if (character.equals("l1")) {                continue;            }            verificationBuilder.append(" && " + character + "!= nil");        }        verificationBuilder.append("){" + "\n");        verificationBuilder.append("   " + leftLetterList.get(0) + "=decimal(" + leftLetterList.get(0) + ");" + "\n");        for (int j = 0; j < rightLetterList.size(); j++) {            String character = rightLetterList.get(j);            if (character.equals("l1")) {                verificationBuilder.append("   let l=getConstant(D);" + "\n");                continue;            }            verificationBuilder.append("   " + character + "=decimal(" + character + ");" + "\n");        }        rightLetterString = rightLetterString.replaceAll("l1", "l");        verificationBuilder.append("   " + "let " + rightLetterList.get(0) + "=" + rightLetterString + ";\n");        verificationBuilder.append("   if(");        verificationBuilder.append(leftLetterList.get(0) + oldSymbol + rightLetterList.get(0));        verificationBuilder.append("){" + "\n");        verificationBuilder.append("       " + "return true;" + "\n");        verificationBuilder.append("   " + "}else{" + "\n");        verificationBuilder.append("       " + "errmsg = \"需满足公式 " + formula + "\";" + "\n");        verificationBuilder.append("       " + "return errmsg;" + "\n");        verificationBuilder.append("   " + "}" + "\n");        verificationBuilder.append("}" + "\n");        verificationBuilder.append("return true;" + "\n");        verificationBuilder.append("\n");        return verificationBuilder;    }    private static String formulaMapping(String oldSymbol, Boolean flag) {        final HashMap<String, String> objectObjectHashMap1 = new HashMap<>();        objectObjectHashMap1.put("≦", "<=");        objectObjectHashMap1.put("≥", ">=");        objectObjectHashMap1.put("≤", "<=");        objectObjectHashMap1.put(">", ">");        objectObjectHashMap1.put("<", "<");        final HashMap<String, String> objectObjectHashMap2 = new HashMap<>();        objectObjectHashMap2.put("≦", ">=");        objectObjectHashMap2.put("≥", "<=");        objectObjectHashMap2.put("≤", ">=");        objectObjectHashMap2.put(">", "<");        objectObjectHashMap2.put("<", ">");        if (flag) {            return objectObjectHashMap1.get(oldSymbol);        } else {            return objectObjectHashMap2.get(oldSymbol);        }    }    private static String fransFormation(String formula) {        // 符号集合        String[] symbol = {"<", ">", "≦", "≥", "≤"};        for (int i = 0; i < symbol.length; i++) {            String str = symbol[i];            // 判断集合中哪种比较符号            if (formula.contains(str)) {                return str;            }        }        return null;    }    private static String[] formulaTransformation(String formula) {        // 符号集合        String[] symbol = {"<", ">", "≦", "≥", "≤"};        for (int i = 0; i < symbol.length; i++) {            String str = symbol[i];            // 判断集合中哪种比较符号            if (formula.contains(str)) {                String[] strList = formula.split(str);                return strList;            }        }        return null;    }    // 检查字符串中是否包含数字    public static ArrayList<String> getElementsNotInSet(List<String> list) {        ArrayList<String> result = new ArrayList<>();        Set<String> set = new HashSet<>();        set.add("2");        set.add("1");        set.add("3");        set.add("100");        for (String item : list) {            if (!set.contains(item)) {                result.add(item);            }        }        return result;    }    private static void generateComputeFile(String filePath, String content) {        if (StrUtil.isBlankIfStr(content)) {            return;        }        File file = new File(filePath);        String absolutePath = file.getAbsolutePath();        // 将绝对路径转化为指定路径        String newPath = absolutePath.replace("aviatorscript\\template", "aviatorscript\\src\\main\\resources\\template");        try {            FileWriter writer = new FileWriter(newPath);            writer.write(content);            writer.close();            System.out.println("计算脚本--文件已生成：" + newPath);        } catch (IOException e) {            e.printStackTrace();        }    }    public static void generateFile(String filePath, String content) {        if (StrUtil.isBlankIfStr(content)) {            return;        }        File file = new File(filePath);        String absolutePath = file.getAbsolutePath();        // 将绝对路径转化为指定路径        String newPath = absolutePath.replace("aviatorscript\\template", "aviatorscript\\src\\main\\resources\\template");        try {            FileWriter writer = new FileWriter(newPath);            writer.write(content);            writer.close();            System.out.println("验证脚本--文件已生成：" + newPath);        } catch (IOException e) {            e.printStackTrace();        }    }    private static Map<String, String> replacements = new HashMap<>();    public static String replaceAll(String input) {        replacements.put("（", "(");        replacements.put("）", ")");        String result = input;        for (Map.Entry<String, String> entry : replacements.entrySet()) {            String target = entry.getKey();            String replacement = entry.getValue();            result = result.replaceAll(target, replacement);        }        return result;    }}