package com.aviator.ketty.conversion;/** * @Author ketty bluce * @Create 2023/7/4 * @Version 1.0 */import cn.hutool.core.io.file.FileReader;import java.io.File;import java.io.FileWriter;import java.io.IOException;import java.util.ArrayList;import java.util.Arrays;import java.util.HashMap;import java.util.List;import java.util.regex.Matcher;import java.util.regex.Pattern;import java.util.stream.Collectors;/** * 模板转化类 */public class TemplateConversion {    // 标注公式注入    public static final String calculateFormula = "template/公式模板.av";    // 验证脚本输出    public static final String exampleConvert = "template/example-convert.av";    // 比较字母公式    static ArrayList<String> leftLetterList = null;    // 计算字母公式    static ArrayList<String> rightLetterList = null;    // 符号集合    static ArrayList<String> operatorList = null;    public static void main(String[] args) {        // 获取公式内容        FileReader fileReader = new FileReader(calculateFormula);        StringBuilder verification = new StringBuilder();        // 去除公式的空格        List<String> strings = fileReader.readLines().stream()                .filter(line -> !line.trim().isEmpty())                .collect(Collectors.toList());        // 解析公式        for (int i = 0; i < strings.size(); i++) {            leftLetterList = new ArrayList<>();            rightLetterList = new ArrayList<>();            operatorList = new ArrayList<>();            // 公式样式            String formula = strings.get(i).replaceAll("##脚本：|\\s", "");            StringBuilder verificationBuilder = new StringBuilder();            if (formula.contains("同时存在")) {                Pattern pattern = Pattern.compile("(.*?)与(.*?)同时存在");                Matcher matcher = pattern.matcher(formula);                if (matcher.find()) {                    leftLetterList.add(matcher.group(1));                    leftLetterList.add(matcher.group(2));                }                verificationBuilder = TypeTwo(formula, strings.get(i));            } else {                // 切分成两半                String[] splist = formulaTransformation(formula);                // 比较符号是什么                String oldSymbol = fransFormation(formula);                // 左边的字母                String aStr = splist[0];                // 右边的字母                String bStr = splist[1];                // 计算公式                String rightLetterString = null;                // 右边的字母-比较字母公式                if (aStr.length() > bStr.length()) {                    leftLetterList.add(bStr);                    oldSymbol = formulaMapping(oldSymbol, false);                    rightLetterString = aStr;                    String replacedStr = "";                    // 全部字母                    String[] newStrList = new String[0];                    replacedStr = aStr.replace("+", ",")                            .replace("-", ",")                            .replace("*", ",")                            .replace("/", ",")                            .replace("(", "")                            .replace(")", "");                    newStrList = replacedStr.split(",");                    // 字母集合按顺序实现                    rightLetterList = new ArrayList<>(Arrays.asList(newStrList));                    // 左边的字母-比较字母公式                } else {                    leftLetterList.add(aStr);                    oldSymbol = formulaMapping(oldSymbol, true);                    rightLetterString = bStr;                    String[] newStrList = new String[0];                    String replacedStr = "";                    replacedStr = bStr.replace("+", ",")                            .replace("-", ",")                            .replace("*", ",")                            .replace("/", ",")                            .replace("(", "")                            .replace(")", "");                    newStrList = replacedStr.split(",");                    // 字母集合按顺序实现                    rightLetterList = new ArrayList<>(Arrays.asList(newStrList));                }                // 去除包含数字的元素                rightLetterList.removeIf(str -> containsDigit(str));                // 开始拼接-验证脚本                verificationBuilder = TypeOne(oldSymbol, rightLetterString, formula, strings.get(i));            }            verification.append(verificationBuilder);            // 开始拼接-计算脚本        }        // 开始执行打印字符        generateFile(exampleConvert, verification.toString());    }    private static StringBuilder TypeTwo(String formula, String str) {        StringBuilder verificationBuilder = new StringBuilder();        verificationBuilder.append(str + "\n");        verificationBuilder.append("let errmsg = nil;" + "\n");        verificationBuilder.append("if(");        for (int i = 0; i < leftLetterList.size(); i++) {            String character = leftLetterList.get(i);            if (i == 0) {                verificationBuilder.append("(" + character + "!= nil");            } else {                verificationBuilder.append(" && " + character + "!= nil" + ")");            }        }        verificationBuilder.append("||");        for (int i = 0; i < leftLetterList.size(); i++) {            String character = leftLetterList.get(i);            if (i == 0) {                verificationBuilder.append("(" + character + "== nil");            } else {                verificationBuilder.append(" && " + character + "== nil" + ")");            }        }        verificationBuilder.append("){" + "\n");        verificationBuilder.append("    " + "return true;" + "\n");        verificationBuilder.append("} else {" + "\n");        verificationBuilder.append("   errmsg = \"" + formula + "\";" + "\n");        verificationBuilder.append("   return errmsg;" + "\n");        verificationBuilder.append("}" + "\n");        return verificationBuilder;    }    private static StringBuilder TypeOne(String oldSymbol, String rightLetterString, String formula, String str) {        StringBuilder verificationBuilder = new StringBuilder();        verificationBuilder.append(str + "\n");        verificationBuilder.append("let errmsg = nil;" + "\n");        verificationBuilder.append("if(");        verificationBuilder.append(leftLetterList.get(0) + "!= nil");        for (int j = 0; j < rightLetterList.size(); j++) {            String character = rightLetterList.get(j);            verificationBuilder.append(" && " + character + "!= nil");        }        verificationBuilder.append("){" + "\n");        verificationBuilder.append("   " + leftLetterList.get(0) + "=decimal(" + leftLetterList.get(0) + ");" + "\n");        for (int j = 0; j < rightLetterList.size(); j++) {            String character = rightLetterList.get(j);            verificationBuilder.append("   " + character + "=decimal(" + character + ");" + "\n");        }        verificationBuilder.append("   " + "let " + rightLetterList.get(0) + "=" + rightLetterString + ";\n");        verificationBuilder.append("   if(");        verificationBuilder.append(leftLetterList.get(0) + oldSymbol + rightLetterList.get(0));        verificationBuilder.append("){" + "\n");        verificationBuilder.append("       " + "return true;" + "\n");        verificationBuilder.append("   " + "}else{" + "\n");        verificationBuilder.append("       " + "errmsg = \"需满足公式 " + formula + "\";" + "\n");        verificationBuilder.append("       " + "return errmsg;" + "\n");        verificationBuilder.append("   " + "}" + "\n");        verificationBuilder.append("}" + "\n");        verificationBuilder.append("return true;" + "\n");        return verificationBuilder;    }    private static String formulaMapping(String oldSymbol, Boolean flag) {        final HashMap<String, String> objectObjectHashMap1 = new HashMap<>();        objectObjectHashMap1.put("≦", "<=");        objectObjectHashMap1.put("≥", ">=");        objectObjectHashMap1.put("≤", "<=");        objectObjectHashMap1.put(">", ">");        objectObjectHashMap1.put("<", "<");        final HashMap<String, String> objectObjectHashMap2 = new HashMap<>();        objectObjectHashMap2.put("≦", ">=");        objectObjectHashMap2.put("≥", "<=");        objectObjectHashMap2.put("≤", ">=");        objectObjectHashMap2.put(">", "<");        objectObjectHashMap2.put("<", ">");        if (flag) {            return objectObjectHashMap1.get(oldSymbol);        } else {            return objectObjectHashMap2.get(oldSymbol);        }    }    private static String fransFormation(String formula) {        // 符号集合        String[] symbol = {"<", ">", "≦", "≥", "≤"};        for (int i = 0; i < symbol.length; i++) {            String str = symbol[i];            // 判断集合中哪种比较符号            if (formula.contains(str)) {                return str;            }        }        return null;    }    private static String[] formulaTransformation(String formula) {        // 符号集合        String[] symbol = {"<", ">", "≦", "≥", "≤"};        for (int i = 0; i < symbol.length; i++) {            String str = symbol[i];            // 判断集合中哪种比较符号            if (formula.contains(str)) {                String[] strList = formula.split(str);                return strList;            }        }        return null;    }    // 检查字符串中是否包含数字    private static boolean containsDigit(String str) {        for (char c : str.toCharArray()) {            if (Character.isDigit(c)) {                return true;            }        }        return false;    }    public static void generateFile(String filePath, String content) {        File file = new File(filePath);        String absolutePath = file.getAbsolutePath();        // 将绝对路径转化为指定路径        String newPath = absolutePath.replace("aviatorscript\\template", "aviatorscript\\src\\main\\resources\\template");        try {            FileWriter writer = new FileWriter(newPath);            writer.write(content);            writer.close();            System.out.println("文件已生成：" + newPath);        } catch (IOException e) {            e.printStackTrace();        }    }}