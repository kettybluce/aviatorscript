let p = productSearchSkuInfo;let list=p.specList;let D=specType;let scMax = nil;let lMin = nil;let newL=nil;## 输入型遍历检查-判断是否存在fn  inputInspection (list,value){    if(list==nil){        return false;    }     for m in list {        if(m.enSpecName==value){            return true;        }     }    return false;}## 根据情况改变最大值fn  changeMaximum(scMax,list,value,flag){    if(scMax==nil){        return false;    }    if(type(scMax)=="long" || type(scMax)=="string"){        scMax=decimal(scMax);    }    for m in list {        for n in m.specRangeList {            if(m.enSpecName == value){                ## 标品计算                if(flag){                    if(scMax <= n.maxValue && scMax >= n.minValue){                        n.maxValue = scMax;                    }                ## 非标品计算                }else{                    if(scMax <= n.maxValue && scMax >= n.minValue){                        n.maxValue = scMax;                ## 最大范围超限制                    }elsif(scMax < n.minValue){                        n.maxValue = 0M;                    }                }            }        }    }}## 改变属性的最小值fn  changeMinimum(lMin,list,value,flag){    if(lMin==nil || lMin < 0){        return false;    }    if(type(lMin)=="long" || type(lMin)=="string"){        lMin=decimal(lMin);    }    for m in list {        for n in m.specRangeList {            if(m.enSpecName == value){                if(flag){                    if(lMin >= n.minValue && lMin <= n.maxValue){                        n.minValue = lMin;                    }                }            }        }    }}## 特殊最大值负值处理fn  changeParticular(scMax,list,value){    if(scMax==nil){        return false;    }    if(type(scMax)=="long" || type(scMax)=="string"){        scMax=decimal(scMax);    }    for m in list {        for n in m.specRangeList {            if(m.enSpecName == value){                n.maxValue = scMax;            }        }    }}## 删除点选的值的范围fn removeValue(saveValue,list,value,flag){    ## 筛选对应的需要消除的点选集合    let new_delete_list=seq.list();    for m in list {        ## 遍历属性集合        if(m.enSpecName==value){            for x in m.specValueList{                if (x.specValue==nil){                    return false;                }                ## 删大于                let compareValue= decimal(x.specValue);                if(flag){                    if(compareValue > saveValue){                        seq.add(new_delete_list,x);                    }                ## 删小于                }else{                    if(compareValue < saveValue){                        seq.add(new_delete_list,x);                    }                }            }            ## 遍历可删除集合，从该属性的点选集合中删除该元素            for q in new_delete_list{                seq.remove(m.specValueList, q);            }        }    }}## 遍历获取对应的值fn  fetchValue(newObject,value){    let newValue=0M;    if(newObject==nil){        return newValue;    }    for m in newObject {        if(m.enSpecName==value){            newValue= decimal(m.attrSpecValue);        }     }    return newValue;}if(D!=nil){    D=decimal(D);}## 5≤ MA ≤D*5## 5≤ MSA ≤D*5## 5≤ MMA ≤D*5## 5≤ MB ≤D*5## 5≤ MSB ≤D*5## 5≤ MMB ≤D*5if(D!=nil){    let newD=D*5;    changeMaximum(newD,list,"MA",true);    changeMaximum(newD,list,"MSA",true);    changeMaximum(newD,list,"MMA",true);    changeMaximum(newD,list,"MB",true);    changeMaximum(newD,list,"MSB",true);    changeMaximum(newD,list,"MMB",true);}## NA≤D-4## NB≤D-4if(D!=nil){    let newD=D-4;    newD = newD < 3M ? 3M : newD;    removeValue(newD,list,"NA",true);    removeValue(newD,list,"NB",true);}## KA≤L-HAif(inputInspection(attrSpec,"L") && inputInspection(appendSpec,"HA")){    let L=fetchValue(attrSpec,"L");    let HA=fetchValue(appendSpec,"HA");    L=L-HA;    changeMaximum(L,list,"KA",true);}## KA≤KB+HB-1-HAif(inputInspection(appendSpec,"KB") && inputInspection(appendSpec,"HB") && inputInspection(appendSpec,"HA")){    let KB=fetchValue(appendSpec,"KB");    let HB=fetchValue(appendSpec,"HB");    let HA=fetchValue(appendSpec,"HA");    KB=KB+HB-1-HA;    changeMaximum(KB,list,"KA",true);}## 复合公式 HAif((type=="KZAC" && D==20)||(type=="KZAF" && D==17) || (type=="KZAN" && D==20)){    if(inputInspection(attrSpec,"L") && inputInspection(appendSpec,"KA")){        let L=fetchValue(attrSpec,"L");        let KC=fetchValue(appendSpec,"KC");        L=L-KC;        if(L>=100){            changeMaximum(100,list,"HA",true);        }else{            changeMaximum(L,list,"HA",true);        }    }elsif(inputInspection(appendSpec,"KB") && inputInspection(appendSpec,"HB") && inputInspection(appendSpec,"KA")){        let KB=fetchValue(appendSpec,"KB");        let HB=fetchValue(appendSpec,"HB");        let KA=fetchValue(appendSpec,"KA");        KB=KB+HB-1-KA;        changeMaximum(KB,list,"HA",true);    }}elsif(inputInspection(attrSpec,"L") && inputInspection(appendSpec,"KA")){     let L=fetchValue(attrSpec,"L");     let KC=fetchValue(appendSpec,"KC");     let newL=L-KC;     changeMaximum(newL,list,"HA",true);}## KB≤L-HBif(inputInspection(attrSpec,"L") && inputInspection(appendSpec,"HB")){    let L=fetchValue(attrSpec,"L");    let HB=fetchValue(appendSpec,"HB");    L=L-HB;    changeMaximum(L,list,"KB",true);}## 复合公式 KBif(inputInspection(appendSpec,"KA") && inputInspection(appendSpec,"HA") && inputInspection(appendSpec,"HB")){    let KA=fetchValue(appendSpec,"KA");    let HA=fetchValue(appendSpec,"HA");    let HB=fetchValue(appendSpec,"HB");    KA=KA+HA+1;    if(HB>=KA){        changeMinimum(0,list,"KB",true);    }else{        changeMinimum(KA,list,"KB",true);    }}## KB≤KC-1-HBif(inputInspection(appendSpec,"KC") && inputInspection(appendSpec,"HB")){    let KC=fetchValue(appendSpec,"KC");    let HB=fetchValue(appendSpec,"HB");    KC=KC-1-HB;    changeMaximum(KC,list,"KB",true);}## KB≥HA+KA+2if(inputInspection(appendSpec,"HA") && inputInspection(appendSpec,"KA")){    let HA=fetchValue(appendSpec,"HA");    let KA=fetchValue(appendSpec,"KA");    HA=HA+KA+2;    changeMaximum(HA,list,"KB",true);}## 复合公式 HBif((type=="KZAC" && D==20)||(type=="KZAF" && D==17) || (type=="KZAN" && D==20)){    if(inputInspection(attrSpec,"L") && inputInspection(appendSpec,"KB")){        let L=fetchValue(attrSpec,"L");        let KB=fetchValue(appendSpec,"KB");        L=L-KB;        if(L>=100){            changeMaximum(100,list,"HB",true);        }else{            changeMaximum(L,list,"HB",true);        }    }elsif(inputInspection(appendSpec,"KC") && inputInspection(appendSpec,"KB")){        let KC=fetchValue(appendSpec,"KC");        let KB=fetchValue(appendSpec,"KB");        KC=KC-1-KB;        changeMaximum(KC,list,"HB",true);    }}elsif(inputInspection(attrSpec,"L") && inputInspection(appendSpec,"KB")){        let L=fetchValue(attrSpec,"L");        let KB=fetchValue(appendSpec,"KB");        let newL=L-KB;        changeMaximum(newL,list,"HA",true);}## KC≤L-HCif(inputInspection(attrSpec,"L") && inputInspection(appendSpec,"HC")){    let L=fetchValue(attrSpec,"L");    let HC=fetchValue(appendSpec,"HC");    L=L-HC;    changeMaximum(L,list,"KC",true);}## KC≥HB+KB+1if(inputInspection(appendSpec,"HB") && inputInspection(appendSpec,"KB")){    let HB=fetchValue(appendSpec,"HB");    let KB=fetchValue(appendSpec,"KB");    HB=HB+KB+1;    changeMaximum(HB,list,"KC",true);}##  KC≤KD-HC-1if(inputInspection(appendSpec,"KD") && inputInspection(appendSpec,"HC")){    let KD=fetchValue(appendSpec,"KD");    let HC=fetchValue(appendSpec,"HC");    KD=KD-HC-1;    changeMinimum(KD,list,"KC",true);}## 复合公式 HCif((type=="KZAC" && D==20)||(type=="KZAF" && D==17)||(type=="KZAN" && D==20)){    if(inputInspection(attrSpec,"L") && inputInspection(appendSpec,"KC")){        let L=fetchValue(attrSpec,"L");        let KC=fetchValue(appendSpec,"KC");        L=L-KC;        if(L>=100){            changeMaximum(100,list,"HC",true);        }else{            changeMaximum(L,list,"HC",true);        }    }elsif(inputInspection(appendSpec,"KD") && inputInspection(appendSpec,"KC")){        let KD=fetchValue(appendSpec,"KD");        let KC=fetchValue(appendSpec,"KC");        KD=KD-KC-1;        changeMaximum(KD,list,"HC",true);    }}elsif(inputInspection(attrSpec,"L") && inputInspection(appendSpec,"KC")){        let L=fetchValue(attrSpec,"L");        let KC=fetchValue(appendSpec,"KC");        let newL=L-KC;        changeMaximum(newL,list,"HC",true);}## 复合公式 HDif((type=="KZAC" && D==20)||(type=="KZAF" && D==17)||(type=="KZAN" && D==20)){    if(inputInspection(attrSpec,"L") && inputInspection(appendSpec,"KD")){        let L=fetchValue(attrSpec,"L");        let KD=fetchValue(appendSpec,"KD");        L=L-KD;        if(L>=100){            changeMaximum(100,list,"HD",true);        }else{            changeMaximum(L,list,"HD",true);        }    }}elsif(inputInspection(attrSpec,"L") && inputInspection(appendSpec,"KD")){        let L=fetchValue(attrSpec,"L");        let KD=fetchValue(appendSpec,"KD");        let newL=L-KD;        changeMaximum(newL,list,"HD",true);}## ZA≤L-HAif(inputInspection(attrSpec,"L") && inputInspection(appendSpec,"HA")){    let L=fetchValue(attrSpec,"L");    let HA=fetchValue(appendSpec,"HA");    L=L-HA;    changeMaximum(L,list,"ZA",true);}## 复合公式 HA_2if((type=="KZAC" && D==20)||(type=="KZAF" && D==17)||(type=="KZAN" && D==20)){    if(inputInspection(attrSpec,"L") && inputInspection(appendSpec,"ZA")){        let L=fetchValue(attrSpec,"L");        let ZA=fetchValue(appendSpec,"ZA");        L=L-ZA;        if(L>=100){            changeMaximum(100,list,"HA_2",true);        }else{            changeMaximum(L,list,"HA_2",true);        }    }}elsif(inputInspection(attrSpec,"L") && inputInspection(appendSpec,"ZA")){        let L=fetchValue(attrSpec,"L");        let ZA=fetchValue(appendSpec,"ZA");        let newL=L-ZA;        changeMaximum(newL,list,"HA_2",true);}## ZB≤L-HB_2if(inputInspection(attrSpec,"L") && inputInspection(appendSpec,"HB_2")){    let L=fetchValue(attrSpec,"L");    let HB_2=fetchValue(appendSpec,"HB_2");    L=L-HB_2;    changeMaximum(L,list,"ZB",true);}## 复合公式 HB_2if((type=="KZAC" && D==20)||(type=="KZAF" && D==17)||(type=="KZAN" && D==20)){    if(inputInspection(attrSpec,"L") && inputInspection(appendSpec,"ZB")){        let L=fetchValue(attrSpec,"L");        let ZB=fetchValue(appendSpec,"ZB");        L=L-ZB;        if(L>=100){            changeMaximum(100,list,"HB_2",true);        }else{            changeMaximum(L,list,"HB_2",true);        }    }}elsif(inputInspection(attrSpec,"L") && inputInspection(appendSpec,"ZB")){        let L=fetchValue(attrSpec,"L");        let ZB=fetchValue(appendSpec,"ZB");        let newL=L-ZB;        changeMaximum(newL,list,"HB_2",true);}## ZD≤L-HD_2if(inputInspection(attrSpec,"L") && inputInspection(appendSpec,"HD_2")){    let L=fetchValue(attrSpec,"L");    let HD_2=fetchValue(appendSpec,"HD_2");    L=L-HD_2;    changeMaximum(L,list,"ZD",true);}## 复合公式 HC_2if((type=="KZAC" && D==20)||(type=="KZAF" && D==17)||(type=="KZAN" && D==20)){    if(inputInspection(attrSpec,"L") && inputInspection(appendSpec,"ZC")){        let L=fetchValue(attrSpec,"L");        let ZC=fetchValue(appendSpec,"ZC");        L=L-ZC;        if(L>=100){            changeMaximum(100,list,"HC_2",true);        }else{            changeMaximum(L,list,"HC_2",true);        }    }}elsif(inputInspection(attrSpec,"L") && inputInspection(appendSpec,"ZC")){        let L=fetchValue(attrSpec,"L");        let ZC=fetchValue(appendSpec,"ZC");        let newL=L-ZC;        changeMaximum(newL,list,"HC_2",true);}## 复合公式 HD_2if((type=="KZAC" && D==20)||(type=="KZAF" && D==17)||(type=="KZAN" && D==20)){    if(inputInspection(attrSpec,"L") && inputInspection(appendSpec,"ZD")){        let L=fetchValue(attrSpec,"L");        let ZD=fetchValue(appendSpec,"ZD");        L=L-ZD;        if(L>=100){            changeMaximum(100,list,"HD_2",true);        }else{            changeMaximum(L,list,"HD_2",true);        }    }}elsif(inputInspection(attrSpec,"L") && inputInspection(appendSpec,"ZD")){        let L=fetchValue(attrSpec,"L");        let ZD=fetchValue(appendSpec,"ZD");        let newL=L-ZD;        changeMaximum(newL,list,"HD_2",true);}## WA≤L-GAif(inputInspection(attrSpec,"L") && inputInspection(appendSpec,"GA")){    let L=fetchValue(attrSpec,"L");    let GA=fetchValue(appendSpec,"GA");    L=L-GA;    changeMaximum(L,list,"WA",true);}## GA≤L-WAif(inputInspection(attrSpec,"L") && inputInspection(appendSpec,"WA")){    let L=fetchValue(attrSpec,"L");    let WA=fetchValue(appendSpec,"WA");    L=L-WA;    changeMaximum(L,list,"GA",true);}## WA+GA+1≤WBif(inputInspection(appendSpec,"WA") && inputInspection(appendSpec,"GA")){    let WA=fetchValue(attrSpec,"WA");    let GA=fetchValue(appendSpec,"GA");    WA=WA+GA+1;    changeMinimum(WA,list,"WB",true);}## WB≤L-GBif(inputInspection(attrSpec,"L") && inputInspection(appendSpec,"GB")){    let L=fetchValue(attrSpec,"L");    let GB=fetchValue(appendSpec,"GB");    L=L-GB;    changeMaximum(L,list,"WB",true);}## GB≤L-WBif(inputInspection(attrSpec,"L") && inputInspection(appendSpec,"WB")){    let L=fetchValue(attrSpec,"L");    let WB=fetchValue(appendSpec,"WB");    L=L-WB;    changeMaximum(L,list,"GB",true);}## WB+GB+1≤WCif(inputInspection(appendSpec,"WB") && inputInspection(appendSpec,"GB")){    let WB=fetchValue(attrSpec,"WB");    let GB=fetchValue(appendSpec,"GB");    WB=WB+GB+1;    changeMinimum(WB,list,"WC",true);}## WC≤L-GCif(inputInspection(attrSpec,"L") && inputInspection(appendSpec,"GC")){    let L=fetchValue(attrSpec,"L");    let GC=fetchValue(appendSpec,"GC");    L=L-GC;    changeMaximum(L,list,"WC",true);}## GC≤L-WCif(inputInspection(attrSpec,"L") && inputInspection(appendSpec,"WC")){    let L=fetchValue(attrSpec,"L");    let WC=fetchValue(appendSpec,"WC");    L=L-WC;    changeMaximum(L,list,"GC",true);}return p;